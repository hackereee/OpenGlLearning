
# 函数
* glViewport 函数设置视口，调用此方法后OpenGl会将 标准化设备坐标转换为屏幕坐标
# 着色器
* 着色器（GLSL）之间无法相互通信，唯一的通信方式是输入和输出
## 向量
* 向量（vec）包含4分量（x、y、z、w）,可以使用vec.x/y...形式获取一个向量上的不同分量，也可以使用`rgba`或者`stpq`形式获取颜色或纹理坐标的分量，他们同获取方式都是一样的
### 向量重组
不同长度的向量可以通过重组的方式得到一个新向量，举例：
```C
vec2 vect = vec(0.2, 0.5)
vec4 result = vect.xyxx
vec4 result1 = vec(vect, 0.3, 0)
```
## Uniform
>>> Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。

## 纹理
* 使用纹理坐标获取纹理颜色叫做采样
* 纹理坐标用来标明属于需要对纹理图片的哪部分进行采样，并传递到片段着色器进行片段插值


## 变换
* opengl 使用列主序进行矩阵存储（按列先后存储）
* glm 库进行矩阵变换的执行顺序与常规书写方式一致，举例有矩阵 m1 , m2 , m3,要执行m3 至 m1的依次转换那是 m1 * m2 * m3, 而在glm里使用也同样的要先调用m3的方法，然后m2 再m1,与代码的阅读顺序刚好相反，用函数表示可以理解为：f(m1f(m2f(m3)))


## 坐标
>> 一个计算机的显示器是2d平面的，一个OpenGl 3d场景的渲染将被作为2d图形投影到屏幕上，GL_PROJECTION 举证呗用作这样的投影变换。首先，它将转换所有的顶点数据从视觉坐标到裁剪坐标.然后这些裁剪坐标又和w分量相除从而转换为标准化设备坐标（NDC）.

* 坐标由l、r、t、b、n、f(左右上下前后)6个分量指定

* 透视除法将4D空间裁剪坐标转换为标准化设备坐标

### 正射投影与透视投影

* 正射投影矩阵创建函数：`glm::ortho`: 例子
 
```
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);

```
* 透视投影矩阵创建函数: `glm::perspective`: 例子

```
//第一个参数表示视野FOV的角度(Field Of View)
glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);

```

[这篇文章](https://www.songho.ca/opengl/gl_projectionmatrix.html)介绍了正射投影和透视投影 


## 摄像机

***注意，以下讨论均以右手坐标系为前提***

建立FPS风格的摄像机，可以固定y轴(0,1,0)，也就是摄像机只能在上下和左右两个方向上旋转，z轴比较好确定(0,0,z),只要两个定义了y和z轴，然后将两个向量叉乘便可以得到垂直于yz平面的x向量，这样就定义好了整个xyz摄像机坐标系

### Look At观察矩阵