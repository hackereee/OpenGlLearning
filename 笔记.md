
# 函数
* glViewport 函数设置视口，调用此方法后OpenGl会将 标准化设备坐标转换为屏幕坐标
# 着色器
* 着色器（GLSL）之间无法相互通信，唯一的通信方式是输入和输出
## 向量
* 向量（vec）包含4分量（x、y、z、w）,可以使用vec.x/y...形式获取一个向量上的不同分量，也可以使用`rgba`或者`stpq`形式获取颜色或纹理坐标的分量，他们同获取方式都是一样的
### 向量重组
不同长度的向量可以通过重组的方式得到一个新向量，举例：
```C
vec2 vect = vec(0.2, 0.5)
vec4 result = vect.xyxx
vec4 result1 = vec(vect, 0.3, 0)
```
## Uniform
>>> Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。

## 纹理
* 使用纹理坐标获取纹理颜色叫做采样
* 纹理坐标用来标明属于需要对纹理图片的哪部分进行采样，并传递到片段着色器进行片段插值


## 变换
* opengl 使用列主序进行矩阵存储（按列先后存储）
* glm 库进行矩阵变换的执行顺序与常规书写方式一致，举例有矩阵 m1 , m2 , m3,要执行m3 至 m1的依次转换那是 m1 * m2 * m3, 而在glm里使用也同样的要先调用m3的方法，然后m2 再m1,与代码的阅读顺序刚好相反，用函数表示可以理解为：f(m1f(m2f(m3)))